using AutoMapper;
using KUNAK.VMS.API.Interfaces;
using KUNAK.VMS.API.Responses;
using KUNAK.VMS.CORE.CustomEntities;
using KUNAK.VMS.CORE.DTOs;
using KUNAK.VMS.CORE.Entities;
using KUNAK.VMS.CORE.Exceptions;
using KUNAK.VMS.CORE.Interfaces;
using KUNAK.VMS.CORE.QueryDTOs;
using KUNAK.VMS.CORE.QueryFilters;
using KUNAK.VMS.INFRASTRUCTURE.Interfaces;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using System.IdentityModel.Tokens.Jwt;

namespace KUNAK.VMS.API.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    //[Authorize]
    public class VulnerabilityAssessmentDetailController : ControllerBase
    {
        private readonly IVulnerabilityAssessmentDetailService _vulnerabilityAssessmentDetailService;
        private readonly IVulnerabilityAssessmentService _vulnerabilityAssessmentService;
        private readonly IAditionalDetailService _aditionalDetailService;
        private readonly IEvidenceService _evidenceService;
        private readonly IDetailHasEvidenceService _detailHasEvidenceService;
        private readonly ICompanyService _companyService;
        private readonly IMapper _mapper;
        private readonly IUriService _uriService;
        //for manage blobs
        private readonly IBlobManagement _blobManagement;

        public VulnerabilityAssessmentDetailController(IVulnerabilityAssessmentDetailService vulnerabilityAssessmentDetailService,
            IVulnerabilityAssessmentService vulnerabilityAssessmentService, IAditionalDetailService aditionalDetailService, IEvidenceService evidenceService,
            IDetailHasEvidenceService detailHasEvidenceService, ICompanyService companyService, IBlobManagement blobManagement, IMapper mapper, IUriService uriService)
        {
            _vulnerabilityAssessmentDetailService = vulnerabilityAssessmentDetailService;
            _vulnerabilityAssessmentService = vulnerabilityAssessmentService;
            _aditionalDetailService = aditionalDetailService;
            _evidenceService = evidenceService;
            _detailHasEvidenceService = detailHasEvidenceService;
            _companyService = companyService;
            _blobManagement = blobManagement;
            _mapper = mapper;
            _uriService = uriService;

        }
        [HttpGet("GetVulnerabilityAssessmentDetails/{idVulnerabilityAssessment}")]
        public IActionResult GetVulnerabilityAssessmentDetails([FromQuery] VulnerabilityAssessmentDetailQueryFilter filters,int idVulnerabilityAssessment)
        {
            try
            {
                //var token = new JwtSecurityTokenHandler().ReadJwtToken(Request.Headers["Authorization"].ToString().Remove(0, 7));

                //if (_validationUserPermissions.RolePermissionValidation(token, _configuration["Permissions:RA_User"].ToString()))
                //{
                var vulnerabilityAssessmentDetails = _vulnerabilityAssessmentDetailService.GetVulnerabilityAssessmentDetails(filters, idVulnerabilityAssessment);
                var vulnerabilityAssessmentDetailsDtos = _mapper.Map<IEnumerable<VulnerabilityAssessmentDetailDTO>>(vulnerabilityAssessmentDetails);
                //Front said that they don't need pagination for this CRUD
                var pagination = new Pagination
                {
                    Length = vulnerabilityAssessmentDetails.Length,
                    Size = vulnerabilityAssessmentDetails.Size,
                    Page = vulnerabilityAssessmentDetails.Page,
                    LastPage = vulnerabilityAssessmentDetails.LastPage,
                    StartIndex = vulnerabilityAssessmentDetails.Count == 0 ? 0 : vulnerabilityAssessmentDetails[0].IdVulnerabilityAssessmentDetail,
                    EndIndex = vulnerabilityAssessmentDetails.Count == 0 ? 0 : vulnerabilityAssessmentDetails[vulnerabilityAssessmentDetails.Count >= vulnerabilityAssessmentDetails.Size ? vulnerabilityAssessmentDetails.Size - 1 : vulnerabilityAssessmentDetails.Count - 1].IdVulnerabilityAssessmentDetail,
                    HasNextPage = vulnerabilityAssessmentDetails.HasNextPage,
                    HasPreviousPage = vulnerabilityAssessmentDetails.HasPreviousPage,
                    NextPageUrl = _uriService.GetVulnerabilityAssessmentDetailPaginationUri(filters, Url.RouteUrl(nameof(GetVulnerabilityAssessmentDetails))).ToString()
                };
                Response.Headers.Add("X-Pagination", JsonConvert.SerializeObject(pagination));

                var response = new
                {
                    Data = vulnerabilityAssessmentDetailsDtos,
                    Pagination = pagination,
                    VulnerabilityAssessment = _mapper.Map<VulnerabilityAssessmentDTO>(_vulnerabilityAssessmentService.GetVulnerabilityAssessmentDetail(idVulnerabilityAssessment))
                };


                //var response = new ApiResponse<IEnumerable<VulnerabilityAssessmentDetailDTO>>(vulnerabilityAssessmentDetailsDtos)
                //{
                //    Pagination = pagination
                //};
                return Ok(response);
                //}
                //else
                //{
                //    return BadRequest("No tiene permiso para realizar esta operación");
                //}
            }
            catch (Exception e)
            {
                return BadRequest(e);
            }
        }


        [HttpGet("{id}")]
        public async Task<IActionResult> GetVulnerabilityAssessmentDetail(int id)
        {
            var vulnerabilityAssessmentDetails = _vulnerabilityAssessmentDetailService.GetVulnerabilityAssessmentDetail(id);
            var vulnerabilityAssessmentDetailsDto = _mapper.Map<VulnerabilityAssessmentDetailDTO>(vulnerabilityAssessmentDetails);
            return Ok(vulnerabilityAssessmentDetailsDto);
        }

        [HttpPost]
        public async Task<IActionResult> PostVulnerabilityAssessmentDetail([FromForm]VulnerabilityAssessmentDetailPostDTO vulnerabilityAssessmentDetailPostDTO)
        {
            try
            {
                //var token = new JwtSecurityTokenHandler().ReadJwtToken(Request.Headers["Authorization"].ToString().Remove(0, 7));
                //company data
                //var idCompany = int.Parse(token.Claims.FirstOrDefault(x => x.Type == "Company").Value);
                var vulnerabilityAssessmentDetail = _mapper.Map<VulnerabilityAssessmentDetail>(vulnerabilityAssessmentDetailPostDTO);

                //Convertir los aditionalDetail que llegan en string a tipo AditionalDetail
                if (vulnerabilityAssessmentDetailPostDTO.AditionalDetailsDtos != null)
                {
                    foreach (var item in vulnerabilityAssessmentDetailPostDTO.AditionalDetailsDtos)
                    {
                        AditionalDetailDTO aditionalDetailDTO = JsonConvert.DeserializeObject<AditionalDetailDTO>(item);

                        //if (aditionalDetailDTO.IdAditionalDetail == 0)
                        //{
                            var aditionalDetail = _mapper.Map<AditionalDetail>(aditionalDetailDTO);
                            vulnerabilityAssessmentDetail.AditionalDetails.Add(aditionalDetail);
                            //await _aditionalDetailService.InsertAditionalDetail(aditionalDetail);
                        //}
                    }
                }
                await _vulnerabilityAssessmentDetailService.InsertVulnerabilityAssessmentDetail(vulnerabilityAssessmentDetail);
                
                
                ////EVIDENCES
                
                ////obtener la vulnerabilidad registrada y guardar las evidencias
                //int idVulnerabilityAssesmentDetail = vulnerabilityAssessmentDetail.IdVulnerabilityAssessmentDetail;

                ////----
                ////Validamos que ningún filename de las avidencias ya esté repetido
                ////We validate that no evidence filename is already repeated
                //if (vulnerabilityAssessmentDetailPostDTO.NewEvidences != null)
                //{
                //    foreach (var item in vulnerabilityAssessmentDetailPostDTO.NewEvidences)
                //    {
                //        DetailHasEvidenceQueryDTO detailHasEvidenceQueryDTO = JsonConvert.DeserializeObject<DetailHasEvidenceQueryDTO>(item);
                //        if (detailHasEvidenceQueryDTO.Evidence.IdEvidence == 0)
                //        {
                //            Evidence evidenceValidation = _evidenceService
                //            .GetEvidenceByName(detailHasEvidenceQueryDTO.Evidence.Filename, detailHasEvidenceQueryDTO.Evidence.IdVulnerabilityAssessment);
                //            if (evidenceValidation != null)
                //            {
                //                throw new BusinessException("La evidencia " + evidenceValidation.Filename + " ya existe");
                //            }
                //        }
                //    }
                //}

                ////SAVE FILES
                //string rucVulnerabilityAssessment= _companyService.GetCompany(idCompany).Ruc + "-gap-" +
                //    vulnerabilityAssessmentDetail.IdVulnerabilityAssessment.ToString();
                //if (vulnerabilityAssessmentDetailPostDTO.Files != null)
                //{
                //    foreach (var item in vulnerabilityAssessmentDetailPostDTO.Files)
                //    {
                //        await _blobManagement.UploadBlob(rucVulnerabilityAssessment, item);
                //    }
                //}
                ////SAVE NEW AND EXISTING EVIDENCES
                //if (vulnerabilityAssessmentDetailPostDTO.NewEvidences != null)
                //{
                //    foreach (var item in vulnerabilityAssessmentDetailPostDTO.NewEvidences)
                //    {
                //        DetailHasEvidenceQueryDTO detailHasEvidenceQueryDTO = JsonConvert.DeserializeObject<DetailHasEvidenceQueryDTO>(item);
                //        if (detailHasEvidenceQueryDTO.IdEvidence == 0)
                //        {
                //            var detailHasEvidence = _mapper.Map<DetailHasEvidence>(detailHasEvidenceQueryDTO);
                //            detailHasEvidence.IdEvidenceNavigation.Date = DateTime.Now;
                //            await _detailHasEvidenceService.InsertDetailHasEvidence(detailHasEvidence);
                //        }
                //        else
                //        {
                //            DetailHasEvidenceDTO detailHasEvidenceDTO = _mapper.Map<DetailHasEvidenceDTO>(detailHasEvidenceQueryDTO);
                //            DetailHasEvidence detailHasEvidence = _mapper.Map<DetailHasEvidence>(detailHasEvidenceDTO);
                //            await _detailHasEvidenceService.InsertDetailHasEvidence(detailHasEvidence);
                //        }
                //    }
                //}
                ////DELETE EXISTING EVIDENCES
                //if (vulnerabilityAssessmentDetailPostDTO.ExistingEvidences != null)
                //{
                //    foreach (var item in vulnerabilityAssessmentDetailPostDTO.ExistingEvidences)
                //    {
                //        DetailHasEvidenceDTO detailHasEvidenceDTO = JsonConvert.DeserializeObject<DetailHasEvidenceDTO>(item);
                //        var detailHasEvidence = _mapper.Map<DetailHasEvidence>(detailHasEvidenceDTO);

                //        //USE ATTRIBUTE STATUS FOR DELETE
                //        if (detailHasEvidence.Status == false)
                //        {
                //            await _detailHasEvidenceService.DeleteDetailHasEvidence(idVulnerabilityAssesmentDetail, detailHasEvidence.IdEvidence);
                //        }
                //    }
                //}
                //await _vulnerabilityAssessmentDetailService.UpdateVulnerabilityAssessmentDetail(vulnerabilityAssessmentDetail);
                //var vulnerabilityAssessmentDetailDto = _vulnerabilityAssessmentDetailService.GetVulnerabilityAssessmentDetail(idVulnerabilityAssesmentDetail); //returns VulnerabilityAssessmentDetail
                //var evaluation = _mapper.Map<VulnerabilityAssessmentDetailDTO>(vulnerabilityAssessmentDetailDto);
                //return Ok(evaluation);
                
                var response = _mapper.Map<VulnerabilityAssessmentDetailDTO>(vulnerabilityAssessmentDetail);
                return Ok(response);
            }
            catch (Exception e)
            {
                return BadRequest(e);
            }
        }

        [HttpPut("{id}")]
        public async Task<IActionResult> PutUser(int id, [FromForm] VulnerabilityAssessmentDetailPostDTO vulnerabilityAssessmentDetailPostDTO)
        {
            try
            {
                var token = new JwtSecurityTokenHandler().ReadJwtToken(Request.Headers["Authorization"].ToString().Remove(0, 7));
                //company data
                var idCompany = int.Parse(token.Claims.FirstOrDefault(x => x.Type == "Company").Value);
                var vulnerabilityAssessmentDetail = _mapper.Map<VulnerabilityAssessmentDetail>(vulnerabilityAssessmentDetailPostDTO);
                vulnerabilityAssessmentDetail.IdVulnerabilityAssessmentDetail = id;
                //Convertir los aditionalDetail que llegan en string a tipo AditionalDetail
                if (vulnerabilityAssessmentDetailPostDTO.AditionalDetailsDtos != null)
                {
                    foreach (var item in vulnerabilityAssessmentDetailPostDTO.AditionalDetailsDtos)
                    {
                        AditionalDetailDTO aditionalDetailDTO = JsonConvert.DeserializeObject<AditionalDetailDTO>(item);

                        if (aditionalDetailDTO.IdAditionalDetail == 0)
                        {
                            var aditionalDetail = _mapper.Map<AditionalDetail>(aditionalDetailDTO);
                            vulnerabilityAssessmentDetail.AditionalDetails.Add(aditionalDetail);
                            //await _aditionalDetailService.InsertAditionalDetail(aditionalDetail);
                        }
                    }
                }
                await _vulnerabilityAssessmentDetailService.InsertVulnerabilityAssessmentDetail(vulnerabilityAssessmentDetail);
                //obtener la vulnerabilidad registrada y guardar las evidencias
                int idVulnerabilityAssesmentDetail = vulnerabilityAssessmentDetail.IdVulnerabilityAssessmentDetail;

                //----
                //Validamos que ningún filename de las avidencias ya esté repetido
                //We validate that no evidence filename is already repeated
                if (vulnerabilityAssessmentDetailPostDTO.NewEvidences != null)
                {
                    foreach (var item in vulnerabilityAssessmentDetailPostDTO.NewEvidences)
                    {
                        DetailHasEvidenceQueryDTO detailHasEvidenceQueryDTO = JsonConvert.DeserializeObject<DetailHasEvidenceQueryDTO>(item);
                        if (detailHasEvidenceQueryDTO.Evidence.IdEvidence == 0)
                        {
                            Evidence evidenceValidation = _evidenceService
                            .GetEvidenceByName(detailHasEvidenceQueryDTO.Evidence.Filename, detailHasEvidenceQueryDTO.Evidence.IdVulnerabilityAssessment);
                            if (evidenceValidation != null)
                            {
                                throw new BusinessException("La evidencia " + evidenceValidation.Filename + " ya existe");
                            }
                        }
                    }
                }

                //SAVE FILES
                string rucVulnerabilityAssessment = _companyService.GetCompany(idCompany).Ruc + "-gap-" +
                    vulnerabilityAssessmentDetail.IdVulnerabilityAssessment.ToString();
                if (vulnerabilityAssessmentDetailPostDTO.Files != null)
                {
                    foreach (var item in vulnerabilityAssessmentDetailPostDTO.Files)
                    {
                        await _blobManagement.UploadBlob(rucVulnerabilityAssessment, item);
                    }
                }
                //SAVE NEW AND EXISTING EVIDENCES
                if (vulnerabilityAssessmentDetailPostDTO.NewEvidences != null)
                {
                    foreach (var item in vulnerabilityAssessmentDetailPostDTO.NewEvidences)
                    {
                        DetailHasEvidenceQueryDTO detailHasEvidenceQueryDTO = JsonConvert.DeserializeObject<DetailHasEvidenceQueryDTO>(item);
                        if (detailHasEvidenceQueryDTO.IdEvidence == 0)
                        {
                            var detailHasEvidence = _mapper.Map<DetailHasEvidence>(detailHasEvidenceQueryDTO);
                            detailHasEvidence.IdEvidenceNavigation.Date = DateTime.Now;
                            await _detailHasEvidenceService.InsertDetailHasEvidence(detailHasEvidence);
                        }
                        else
                        {
                            DetailHasEvidenceDTO detailHasEvidenceDTO = _mapper.Map<DetailHasEvidenceDTO>(detailHasEvidenceQueryDTO);
                            DetailHasEvidence detailHasEvidence = _mapper.Map<DetailHasEvidence>(detailHasEvidenceDTO);
                            await _detailHasEvidenceService.InsertDetailHasEvidence(detailHasEvidence);
                        }
                    }
                }
                //DELETE EXISTING EVIDENCES
                if (vulnerabilityAssessmentDetailPostDTO.ExistingEvidences != null)
                {
                    foreach (var item in vulnerabilityAssessmentDetailPostDTO.ExistingEvidences)
                    {
                        DetailHasEvidenceDTO detailHasEvidenceDTO = JsonConvert.DeserializeObject<DetailHasEvidenceDTO>(item);
                        var detailHasEvidence = _mapper.Map<DetailHasEvidence>(detailHasEvidenceDTO);

                        //USE ATTRIBUTE STATUS FOR DELETE
                        if (detailHasEvidence.Status == false)
                        {
                            await _detailHasEvidenceService.DeleteDetailHasEvidence(idVulnerabilityAssesmentDetail, detailHasEvidence.IdEvidence);
                        }
                    }
                }
                await _vulnerabilityAssessmentDetailService.UpdateVulnerabilityAssessmentDetail(vulnerabilityAssessmentDetail);
                var vulnerabilityAssessmentDetailDto = _vulnerabilityAssessmentDetailService.GetVulnerabilityAssessmentDetail(idVulnerabilityAssesmentDetail); //returns VulnerabilityAssessmentDetail
                var evaluation = _mapper.Map<VulnerabilityAssessmentDetailDTO>(vulnerabilityAssessmentDetailDto);
                return Ok(evaluation);

                //var response = _mapper.Map<VulnerabilityAssessmentDetailDTO>(vulnerabilityAssessmentDetail);
                //return Ok(response);
            }
            catch (Exception e)
            {
                return BadRequest(e);
            }
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteVulnerabilityAssessmentDetail(int id)
        {
            try
            {
                var result = await _vulnerabilityAssessmentDetailService.DeleteVulnerabilityAssessmentDetail(id);
                return Ok(result);
            }
            catch (Exception e)
            {
                return BadRequest(e);
            }
        }
    }
}
