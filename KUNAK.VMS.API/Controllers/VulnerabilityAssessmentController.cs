using AutoMapper;
using KUNAK.VMS.API.Interfaces;
using KUNAK.VMS.API.Responses;
using KUNAK.VMS.CORE.CustomEntities;
using KUNAK.VMS.CORE.DTOs;
using KUNAK.VMS.CORE.Entities;
using KUNAK.VMS.CORE.Interfaces;
using KUNAK.VMS.CORE.QueryDTOs;
using KUNAK.VMS.CORE.QueryFilters;
using KUNAK.VMS.INFRASTRUCTURE.Interfaces;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using System.IdentityModel.Tokens.Jwt;

namespace KUNAK.VMS.API.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [Authorize]
    public class VulnerabilityAssessmentController : ControllerBase
    {
        private readonly IVulnerabilityAssessmentService _vulnerabilityAssessmentService; 
        private readonly IVulnerabilityAssessmentDetailService _vulnerabilityAssessmentDetailService; 
        private readonly IConsultantHasVulnerabilityAssessmentService _consultantHasVulnerabilityAssessmentService;
        private readonly ICompanyService _companyService;
        private readonly IUserService _userService;
        private readonly IMapper _mapper;
        private readonly IUriService _uriService;
        private readonly IBlobManagement _blobManagement;

        public VulnerabilityAssessmentController(IVulnerabilityAssessmentService vulnerabilityAssessmentService,
            IVulnerabilityAssessmentDetailService vulnerabilityAssessmentDetailService,
            IConsultantHasVulnerabilityAssessmentService consultantHasVulnerabilityAssessmentService,
            ICompanyService companyService, IUserService userService,IMapper mapper, IUriService uriService,
            IBlobManagement blobManagement)
        {
            _vulnerabilityAssessmentService = vulnerabilityAssessmentService;
            _vulnerabilityAssessmentDetailService = vulnerabilityAssessmentDetailService;
            _consultantHasVulnerabilityAssessmentService = consultantHasVulnerabilityAssessmentService;
            _companyService= companyService;
            _userService = userService;
            _mapper = mapper;
            _uriService = uriService;
            _blobManagement = blobManagement;
        }
        [HttpGet]
        public IActionResult GetVulnerabilityAssessments([FromQuery] VulnerabilityAssessmentQueryFilter filters)
        {
            try
            {
                var token = new JwtSecurityTokenHandler().ReadJwtToken(Request.Headers["Authorization"].ToString().Remove(0, 7));

                //if (_validationUserPermissions.RolePermissionValidation(token, _configuration["Permissions:RA_User"].ToString()))
                //{
                var idRole= int.Parse(token.Claims.FirstOrDefault(x => x.Type == "idRole").Value);
                if (idRole==1)
                {
                    var idUser= int.Parse(token.Claims.FirstOrDefault(x => x.Type == "idUser").Value);
                    var consultantHasVulnerabilityAssessments = _consultantHasVulnerabilityAssessmentService.GetVulnerabilityAssessmentsByIdUser(filters,idUser);
                    var vulnerabilityAssessments = new List<VulnerabilityAssessment> { };
                    foreach (var consultantHasVulnerabilityAssessment in consultantHasVulnerabilityAssessments)
                    {
                        var vulnerabilityAssessment = _vulnerabilityAssessmentService.GetVulnerabilityAssessmentDetail(consultantHasVulnerabilityAssessment.IdVulnerabilityAssessment);
                        vulnerabilityAssessments.Add(vulnerabilityAssessment);
                    }
                    var vulnerabityAssessmentsssessmentsDtos = _mapper.Map<IEnumerable<VulnerabilityAssessmentMethodologyAscopeDTO>>(vulnerabilityAssessments);
                    //Front said that they don't need pagination for this CRUD
                    var pagination = new Pagination
                    {
                        Length = consultantHasVulnerabilityAssessments.Length,
                        Size = consultantHasVulnerabilityAssessments.Size,
                        Page = consultantHasVulnerabilityAssessments.Page,
                        LastPage = consultantHasVulnerabilityAssessments.LastPage,
                        StartIndex = consultantHasVulnerabilityAssessments.Count == 0 ? 0 : consultantHasVulnerabilityAssessments[0].IdVulnerabilityAssessment,
                        EndIndex = consultantHasVulnerabilityAssessments.Count == 0 ? 0 : consultantHasVulnerabilityAssessments[consultantHasVulnerabilityAssessments.Count >= consultantHasVulnerabilityAssessments.Size ? consultantHasVulnerabilityAssessments.Size - 1 : consultantHasVulnerabilityAssessments.Count - 1].IdVulnerabilityAssessment,
                        HasNextPage = consultantHasVulnerabilityAssessments.HasNextPage,
                        HasPreviousPage = consultantHasVulnerabilityAssessments.HasPreviousPage,
                        NextPageUrl = _uriService.GetVulnerabilityAssessmentPaginationUri(filters, Url.RouteUrl(nameof(GetVulnerabilityAssessments))).ToString()
                    };
                    Response.Headers.Add("X-Pagination", JsonConvert.SerializeObject(pagination));

                    var response = new ApiResponse<IEnumerable<VulnerabilityAssessmentMethodologyAscopeDTO>>(vulnerabityAssessmentsssessmentsDtos)
                    {
                        Pagination = pagination
                    };
                    return Ok(response);
                }
                else
                {
                    int idCompany = int.Parse(token.Claims.FirstOrDefault(x => x.Type == "Company").Value);
                    var vulnerabilityAssessments = _vulnerabilityAssessmentService.GetVulnerabilityAssessmentsByIdCompany(filters, idCompany);
                    var vulnerabilityAssessmentsDtos = _mapper.Map<IEnumerable<VulnerabilityAssessmentMethodologyAscopeDTO>>(vulnerabilityAssessments);
                    
                    //Front said that they don't need pagination for this CRUD
                    var pagination = new Pagination
                    {
                        Length = vulnerabilityAssessments.Length,
                        Size = vulnerabilityAssessments.Size,
                        Page = vulnerabilityAssessments.Page,
                        LastPage = vulnerabilityAssessments.LastPage,
                        StartIndex = vulnerabilityAssessments.Count == 0 ? 0 : vulnerabilityAssessments[0].IdVulnerabilityAssessment,
                        EndIndex = vulnerabilityAssessments.Count == 0 ? 0 : vulnerabilityAssessments[vulnerabilityAssessments.Count >= vulnerabilityAssessments.Size ? vulnerabilityAssessments.Size - 1 : vulnerabilityAssessments.Count - 1].IdVulnerabilityAssessment,
                        HasNextPage = vulnerabilityAssessments.HasNextPage,
                        HasPreviousPage = vulnerabilityAssessments.HasPreviousPage,
                        NextPageUrl = _uriService.GetVulnerabilityAssessmentPaginationUri(filters, Url.RouteUrl(nameof(GetVulnerabilityAssessments))).ToString()
                    };
                    Response.Headers.Add("X-Pagination", JsonConvert.SerializeObject(pagination));

                    var response = new ApiResponse<IEnumerable<VulnerabilityAssessmentMethodologyAscopeDTO>>(vulnerabilityAssessmentsDtos)
                    {
                        Pagination = pagination
                    };
                    return Ok(response);
                }
                



                //}
                //else
                //{
                //    return BadRequest("No tiene permiso para realizar esta operación");
                //}
            }
            catch (Exception e)
            {
                return BadRequest(e);
            }
        }


        [HttpGet("{id}")]
        public async Task<IActionResult> GetVulnerabilityAssessment(int id)
        {
            var vulnerabilityAssessments = await _vulnerabilityAssessmentService.GetVulnerabilityAssessment(id);
            var vulnerabilityAssessmentsDto = _mapper.Map<VulnerabilityAssessmentDTO>(vulnerabilityAssessments);
            return Ok(vulnerabilityAssessmentsDto);
        }

        [HttpPost]
        public async Task<IActionResult> PostVulnerabilityAssessment(VulnerabilityAssessmentPostDTO vulnerabilityAssessmentDTO)
        {
            try
            {
                var token = new JwtSecurityTokenHandler().ReadJwtToken(Request.Headers["Authorization"].ToString().Remove(0, 7));

                //if (_validationUserPermissions.RolePermissionValidation(token, _configuration["Permissions:RA_User"].ToString()))
                //{
                int idCompany = int.Parse(token.Claims.FirstOrDefault(x => x.Type == "Company").Value);
                var vulnerabilityAssessment = _mapper.Map<VulnerabilityAssessment>(vulnerabilityAssessmentDTO);
                var idRole = int.Parse(token.Claims.FirstOrDefault(x => x.Type == "idRole").Value);
                if (idRole != 1)
                {
                    vulnerabilityAssessment.IdCompany = idCompany;
                }
                await _vulnerabilityAssessmentService.InsertVulnerabilityAssessment(vulnerabilityAssessment);
                var response = _mapper.Map<VulnerabilityAssessmentPostDTO>(vulnerabilityAssessment);

                //CREATE CONTAINER FOR VMS
                // se debe poner vulnerabilityAssessment.IdCompany porque no siempre será el
                // idCompany que sale del token
                var containerVulnerabilityAssessment = _companyService.GetCompany(vulnerabilityAssessment.IdCompany).Ruc + "-vms-" + response.IdVulnerabilityAssessment;
                await _blobManagement.CreateContainer(containerVulnerabilityAssessment);


                return Ok(response);
            }
            catch (Exception e)
            {
                return BadRequest(e);
            }
        }

        [HttpPut("{id}")]
        public async Task<IActionResult> PutUser(int id, VulnerabilityAssessmentPostDTO vulnerabilityAssessmentDTO)
        {
            try
            {
                var token = new JwtSecurityTokenHandler().ReadJwtToken(Request.Headers["Authorization"].ToString().Remove(0, 7));

                var idRole = int.Parse(token.Claims.FirstOrDefault(x => x.Type == "idRole").Value);
                int idCompany = int.Parse(token.Claims.FirstOrDefault(x => x.Type == "Company").Value);
                var vulnerabilityAssessment = _mapper.Map<VulnerabilityAssessment>(vulnerabilityAssessmentDTO);
                vulnerabilityAssessment.IdVulnerabilityAssessment = id;
                if (idRole != 1)
                {
                    vulnerabilityAssessment.IdCompany = idCompany;
                }
                await _vulnerabilityAssessmentService.UpdateVulnerabilityAssessment(vulnerabilityAssessment);
                var vulnerabilityAssessmentEdit = _vulnerabilityAssessmentService.GetVulnerabilityAssessmentDetail(id);
                var response = _mapper.Map<VulnerabilityAssessmentPostDTO>(vulnerabilityAssessmentEdit);
                return Ok(response);
            }
            catch (Exception e)
            {
                return BadRequest(e);
            }
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteVulnerabilityAssessment(int id)
        {
            try
            {
                var result = await _vulnerabilityAssessmentService.DeleteVulnerabilityAssessment(id);
                return Ok(result);
            }
            catch (Exception e)
            {
                return BadRequest(e);
            }
        }
    }
}
